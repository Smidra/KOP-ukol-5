\input opmac
\chyph

\tit Řešení problému vážené splnitelnosti booleovské formule pokročilou iterativní metodou
\centerline{\bf 16. ledna 2021, Radek Šmíd}
\medskip
\centerline{\it https://github.com/Smidra/KOP-ukol-5}


% Specifikace úlohy
\sec Specifikace úlohy
Cílem úlohy bylo implementovat jeden z pokročilých algoritmů pro řešení váženého problému 3SAT.\break
Na výběr bylo z:

\begitems
* Simulované ochlazování
* Genetické algoritmy
* Tabu search
\enditems

Po úspěšném nasazení algoritmu bylo za úkol jeho vlastnosti ověřit experimentálním vyhodnocením. Zpráva by měla dokládat záznam o celém postupu řešení problému a nsazení. Proces experimentace (white box i black box fáze testování) jsem se pokusil zachytit v tomto dokumentu. Výsledné naměřené hodnoty pak prezentovat a pokusit se o interpretaci\fnote{https://moodle-vyuka.cvut.cz/mod/assign/view.php?id=89703}.


% Co je to simulované ochlazování
\sec Stručný popis zvoleného algoritmu
Zvolil jsem si algoritmus simulovaného ochlazování, stejně jako v předchozí úloze. Je to pravděpodobnostní metoda řešení problému založená na analogii se simulací ochlazování tuhnoucího kovu. Metoda prohledává stavový prostor a má tendenci zůstávat v lokálních minimech. Algoritmus nezaručuje nalezení globálního minima, ale správým nastavením jeho parametrů (teplota, chladící koeficient) můžeme docílit velmi přesných výsledků.


% Rozbor možných řešení + Jak jsem řešil já
\sec Rozbor řešení
Řešení staví na pevných základech objektového návrhu z předchozích cvičení. Pro tuto úlohu jsem ale nemohl předchozí kód pouze rozšířit o novou metodu. Musel jsem značné části celého kódu přepsat a vytvořit tak nové třídy, které korektně implementují problém váženého 3SAT (dále už jen 3SAT). Instance 3SAT problému jsou drženy v poli jako objetky třídy CNFInstance. Třídu KnapsackState z předchozího cvičení jsem přepsal jako třídu CNFState. Ta reprezentuje jeden stav (ohodnocení proměnných) nějaké instance 3SAT.

Má metody:
\begitems
* is\_solution() -- Vrací bool podle toho jestli jsou všechny maxtermy pravda pro toto ohodnocení. Pokud nějaký maxterm není splněný, poznamená si proměnné, které se v něm vyskytují jako \uv{podezřelé}.
* refresh() -- Zavolá is\_solution() aby vystavěl aktuální množinu podezřelých proměnných. Pak spočítá celkovou váhu pro toto konkrétní ohodnocení.
* flip( n ) -- Proměnnou na pozici $n$ invertuje (0 na 1, nebo 1 na 0)
* randomize() -- Ohodnotí proměnné náhodně a zavolá metodu refresh().
* random\_start() -- Pokusí se oprakovaných voláním metody randomize() nalézt platné řešení. Pokud ho po n krát 1000 krocích nenalezne, spokojí se s jakýmkoliv náhodným stavem.
* is\_better( state\_challenger ) -- Porovná, jestli tento stav lepší než challenger stav. Více níže.
* random\_neighbour() -- Vrátí náhodný sousední stav. Více níže.
\enditems

\secc Stavový prostor
Jako stavový prostor 3SAT problému jsem zvolil všecha možná ohodnocení proměnných. Algoritmus tedy připouští i takové stavy, které mají proměnné ohodnocené tak, že celková CNF není splněna. Zvolil jsem tento prostor proto, že je spojitý a jistě obsahuje optimální řešení. Taková volba značně ztíží vyladění algoritmu, protože jistě budou existovat takové stavy, které mají lepší váhu, ale nejsou řešení. Pro získání co nejlepších vlastností podle přednášky je prospěšné začínat z náhodného stavu. Proto je třeba vygenerovat na začátek náhodné řešení. Jenže to také nemusíme najít.

\secc random\_start()
Tato funkce se použije při hledání startovacího stavu. V cyklu randomizuje stav a ptá se jestli je to validní řešení. Tento cyklus opakuje až do tisícinásobku počtu proměnných. Pokud se jí ani pak nepodaří najít validní řešení svojí práci vzdá a začne od jakéhokoliv náhodného řešení.

\secc Operace
Zvolené operace jsou změna jednoho bitu. Tedy buď změna ohodnocení proměnné z 1 na 0, nebo naopak. Tato operace je implementována metodou flip(). Po změně je vždy volána metoda refresh(), která atributy objektu aktualizuje.

\sec is\_better(state\_challenger)
Metoda, která rozhodne, jestli je lepší tento stav, nebo vyzivatel. Po dlouhé úvaze jsem se rozhodl tuto metodu ponechat implementovanou obdobně jako v úloze 4. Existují čtyři možnosti, které mohou nastat.

\begitems
* Tento (je řešení) x Vyzivatel (je řešení) -- Rozhodne lepší váha.
* Tento (není řešení) x Vyzivatel (není řešení) -- Rozhodne lepší váha.
* Tento (není řešení) x Vyzivatel (je řešení) -- Tento je lepší.
* Tento (je řešení) x Vyzivatel (není řešení) -- Vyzivatel je lepší.
\enditems

\secc random\_neighbour()
Se použije ve funkci {\bf try()}, kde vybírám náhodného souseda. Tedy takový stav, pro který stačí použít jednou metodu flip. Nalezený soused nemusí být validní řešení. Abych pomohl heuristice od  \uv{bezcílného} bloudění, tak se nejdříve podívám, zda je stav řešení. Pokud není, pak cesta k řešení vede pouze skrz obracení proměnných přítomných v nesplněných maxtermech. Pokud stav je řešení, vyberu náhodnou proměnnou (s plným vědomím, že pokud to nebude řešení, tak vždy zvítězí stávající stav).

\secc Normalizace ceny
Aby nehrály roli jednotky ve kterých je váha uvedena (koruny/haléře), tak jsem rozdíl cen implementoval speciální funkcí. Ta vezme váhu prvního stavu ($c1$) a vypočítá konstantu $a$ pomocí které lze naškálovat $c1$ na 100. Váhu druhého stavu pak vynásobí stejnou konstantou. Od $100$ pak odečte $c2$ a získá normalizovaný rozdíl vah stavů, který se nebude s jednotkami měnit. Tím získáme stabilnější algoritmus, protože abolutní velikosti vah nebudou mít vliv na teplotu při vyhodnocování funkce try(). Úplně stejně jako s cenami v úloze 4.


\secc Ukončení
Funkce frozen vrátí True po 300 kolech beze změny. Funkce equilibrium vrátí True po dvojnásobku počtu věcí v instanci.


\vfill\break
\sec Experimentace
Proces experimentace jsem si téměř celý automatizoval. Program generuje do souboru {\bf chart\_X\_YZ.dat} vývoj váhy, přímo zatímco ji počítá. GNU Octave tento soubor čte a na pořádání z něj rovnou vytvoří graf vývoje váhy v krocích.

Používám dodané instance {\bf wuf20-78-M1} o velikosti dvaceti proměnných a sedmdesáti osmi maxtermy. Prvotní nastavení parametrů by mohlo být náhodné, ale rozhodl jsem se pro výsledné hodnoty čtvrtého úkolu. Tedy  $t = 30$ a $c = 0.97$. V první fázi se pokusím vyladit algoritmus na instanci problému s $id=01$.

Sleduji vývoj ceny v grafu níže. Algoritmus došel k řešení 6403, což je správné řešení první instance. Graf vypadá tak, jak by měl -- konverguje v polovině až dvou třetinách.



\centerline{ \picwidth=17cm \inspic{chart01.pdf} }
\caption/f Vývoj ceny stavu pro první experiment.
\bigskip


%\centerline{\table{r|l}{
%Běh&Chyba\crl
%1.&0\cr
%}}\bigskip
















\vfill\break
% Přehledná prezentace výsledků
\sec Zhodnocení experimentů
% Graf čas + chybovost
% Graf postupného vývoje ceny


Zkusíme běh na 100 instancích o velikosti 32. Hodnoty srovnáme s dodaným referenčním řešením.

\bigskip
\centerline{\table{r|r|r}{
{\bf 2/0.97}&MAX&AVG\crl
Chyba&70.9\%&7.9\%\cr
Čas&2.91s&1.32s\cr
}}\bigskip


Ukazuje se, že čas je sice skvělý a průměrná chybovost také. Bohužel je ale maximální chyba opravdu příliš vysoko. Vraťme se tedy zpět k ladění parametrů. Pro zvýšení přesnosti na úkor času zvedneme původní teplotu na $t=5$. Celkové hodnoty po testování na 100 instancí se změnily na:

\bigskip
\centerline{\table{r|r|r}{
{\bf 5/0.97}&MAX&AVG\crl
Chyba& 51.4\%& 2.7\%\cr
Čas  & 8.7s& 3.0s\cr
}}\bigskip

To je bohužel stále moc veliká chybovost. Zkusme se podívat i na jiné parametry. Je možné, že mám příliš rychlou ukončovancí podmínku. Tedy, že se tavenina příliš rychle prohlásí za zmraženou. Místo třiceti kol bez žádné změny toto číslo rapidně zvednu na 300. Abych dosahoval výrazně lepší chybovosti razantně také zvednu teplotu na $t=30$.

% Obrázek graf09.pdf
%\centerline{ \picwidth=17cm \inspic{graf19.pdf} }
%\caption/f Vývoj ceny stavu pro osmý experiment.
%\bigskip

Vypadá to, že jsme nalezli chybu. Heuristika se úspěšně usadila v nejlepším stavu. Přitom kroků bylo ještě přijatelné množství. Přejdeme tedy s touto nejnovější iterací parametrů zpátky do black--box testingu. Pustím heuristiku zase na 100 instancí a zaznamenám vlastnosti řešení.

\bigskip
\centerline{\table{r|r|r}{
{\bf 30/0.97}&MAX&AVG\crl
Chyba& 5.5\%& 0.6\%\cr
Čas  &  21.8s& 9.6s\cr
}}\bigskip

\hfill $\epsilon\upsilon\rho\eta\kappa\alpha$!

Řešení je nyní velmi uspokojivé, přijmeme ho a experimentaci ukončíme.









% Interpretace výsledků
\sec Závěr
V domácím úkolu jsem implementoval simulované ochlazování a pokusil se metodickým přístupem nalézt nejlepší parametry pro zadané NK--32 instance. Herustika velmi citlivě ragovala na změnu všech parametrů. Nejenom ale na dva hlavní (počáteční teplotu a ochlazovací koeficient). Je také zásadní mít korektně nastavené hodnoty ukončování pro metodu frozen. Zyšování počáteční teploty a chladícího koeficientu pomalu vylaďujeme intezifikaci a diverzifikaci heuristiky pro náš algoritmus. Vyzkoušel jsem si práci s pokročilou heuristikou a upravil svůj program na automatizaci úkonů spojených s vizualizací od pythonu až po matlab grafy. 




\bye
